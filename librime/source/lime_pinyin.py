#!/usr/bin/env python3
# -*- coding:utf-8 -*-

import sys
import os
import sqlite3
import uuid
import time
import hashlib
import copy

MAX_CONSONANT_INDEX = 23

TPL_HEADER = '''\
/* vim: set fileencoding=utf-8:
 * 
 *                   GNU GENERAL PUBLIC LICENSE
 *                       Version 2, June 1991
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * @author  buaabyl@gmail.com
 * @ref sunpinyin
 *
 *  2012.10.01
 *      I read sunpinyin source code, and design this library,
 *      so the license must be GPL or LGPL
 *      implement it in flex+bison
 *
 */
/***************************************************/
/*       !!! DO NOT MODIFY THIS FILE !!!           */ 
/*    generated by lime_pinyin.py automatically    */
/*                                                 */
/***************************************************/

'''

PINYIN_LUT = {
    # consonant
    ' '   : 0,
    'b'   : 1,
    'c'   : 2,
    'ch'  : 3,
    'd'   : 4,
    'f'   : 5,
    'g'   : 6,
    'h'   : 7,
    'j'   : 8,
    'k'   : 9,
    'l'   : 10,
    'm'   : 11,
    'n'   : 12,
    'p'   : 13,
    'q'   : 14,
    'r'   : 15,
    's'   : 16,
    'sh'  : 17,
    't'   : 18,
    'w'   : 19,
    'x'   : 20,
    'y'   : 21,
    'z'   : 22,
    'zh'  : 23,

    #vowel
    'a'   : 24,
    'ai'  : 25,
    'an'  : 26,
    'ang' : 27,
    'ao'  : 28,
    'e'   : 29,
    'ei'  : 30,
    'en'  : 31,
    'eng' : 32,
    'er'  : 33,
    'i'   : 34,
    'ia'  : 35,
    'ian' : 36,
    'iang': 37,
    'iao' : 38,
    'ie'  : 39,
    'in'  : 40,
    'ing' : 41,
    'iong': 42,
    'iu'  : 43,
    'o'   : 44,
    'ong' : 45,
    'ou'  : 46,
    'u'   : 47,
    'ua'  : 48,
    'uai' : 49,
    'uan' : 50,
    'uang': 51,
    'ue'  : 52,
    'ui'  : 53,
    'un'  : 54,
    'uo'  : 55,
    'v'   : 56,
}
PINYIN_LUT_REVERSE = {}

VALID_PAIRS = {
    " " :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "er", "o", "ou"],
    "b" :  ["a", "ai", "an", "ang", "ao", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "u"],
    "p" :  ["a", "ai", "an", "ang", "ao", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "ou", "u"],
    "m" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "iu", "o", "ou", "u"],
    "f" :  ["a", "an", "ang", "ei", "en", "eng", "iao", "o", "ou", "u"],
    "d" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ia", "ian", "iao", "ie", "ing", "iu", "ong", "ou", "u", "uan", "ui", "un", "uo"],
    "t" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "eng", "i", "ian", "iao", "ie", "ing", "ong", "ou", "u", "uan", "ui", "un", "uo"],
    "n" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan", "un", "uo", "v", "ue"],
    "l" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "eng", "i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iu", "o", "ong", "ou", "u", "uan", "un", "uo", "v", "ue"],
    "g" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "k" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "h" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "j" :  ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"],
    "q" :  ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"],
    "x" :  ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"],
    "zh":  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "ch":  ["a", "ai", "an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "sh":  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"],
    "r" :  ["an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "ua", "uan", "ui", "un", "uo"],
    "z" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"],
    "c" :  ["a", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"],
    "s" :  ["a", "ai", "an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"],
    "y" :  ["a", "an", "ang", "ao", "e", "i", "in", "ing", "o", "ong", "ou", "u", "uan", "ue", "un"],
    "w" :  ["a", "ai", "an", "ang", "ei", "en", "eng", "o", "u"],
}

FUNCTIONS = '''
int lime_is_paired_by_id(int consonant, int vowel)
{
    if (consonant > MAX_CONSONANT_INDEX) {
        return 0;
    }
    if (vowel <= MAX_CONSONANT_INDEX) {
        return 0;
    }
    if (vowel > MAX_PRONOUNCE_INDEX) {
        return 0;
    }

    if (_pair_array[consonant][vowel - MAX_CONSONANT_INDEX - 1]) {
        return 1;
    }

    return 0;
}

int lime_is_paired_by_str(const char* consonant, const char* vowel)
{
    int consonant_id;
    int vowel_id;

    consonant_id = lime_map_by_pronounce(consonant, -1);
    vowel_id     = lime_map_by_pronounce(vowel, -1);

    return lime_is_paired_by_id(consonant_id, vowel_id);
}

'''

def write_header(fn):
    f = open(fn, 'w')

    raw = hashlib.sha512(str(uuid.uuid1()).encode('UTF-8')).hexdigest()
    uuids = [0,0,0,0,0]
    uuids[0] = raw[:8]
    uuids[1] = raw[8:12]
    uuids[2] = raw[12:16]
    uuids[3] = raw[16:20]
    uuids[4] = raw[20:32]
    uuidstr  = '_'.join(uuids).upper()

    f.write(TPL_HEADER)
    macro = '%s_%s_INCLUDED_' % (fn.replace('.', '_').upper(), uuidstr)
    f.write('#ifndef %s\n' % macro)
    f.write('#define %s\n' % macro)
    f.write('\n')

    f.write('#define MAX_PRONOUNCE_LENGTH   4\n')
    f.write('#define MAX_PRONOUNCE_INDEX    %d\n' % (len(PINYIN_LUT) - 1))
    f.write('#define MAX_CONSONANT_INDEX    %d // %s\n' % 
            (MAX_CONSONANT_INDEX, PINYIN_LUT_REVERSE[MAX_CONSONANT_INDEX]))
    f.write('\n')


    f.write('/*\n')
    f.write(' * @brief   convert string to internal defined value\n')
    f.write(' * @return  [0, MAX_PRONOUNCE_INDEX)\n')
    f.write(' * @retval  -1      invalid\n')
    f.write(' */\n')
    f.write('int lime_map_by_pronounce(const char* s, int len);\n')
    f.write('\n')

    f.write('const char* lime_map_to_pronounce(int id);\n')
    f.write('\n')

    f.write('int lime_is_paired_by_id(int consonant, int vowel);\n');
    f.write('int lime_is_paired_by_str(const char* consonant, const char* vowel);\n');

    f.write('\n')
    f.write('#endif\n')
    f.write('\n')
    f.close()


def write_cfile(hfn, cfn):
    f = open(cfn, 'w')

    f.write(TPL_HEADER)
    f.write('#include <stdio.h>\n')
    f.write('#include <stdlib.h>\n')
    f.write('#include <string.h>\n')
    f.write('#include "%s"\n' % hfn)
    f.write('\n')


    f.write('/*\n')
    f.write(' * @brief   valid consonant and vowel pair lookup table\n')
    f.write(' * @descriptions\n')
    f.write(' *      array[consonant_id][vowel_id - MAX_CONSONANT_INDEX - 1]\n')
    f.write(' */\n')
    f.write('static const int _pair_array[%d][%d] = {\n' % (MAX_CONSONANT_INDEX+1, len(PINYIN_LUT) - MAX_CONSONANT_INDEX))
    for first in range(0, MAX_CONSONANT_INDEX+1):
        first_s = PINYIN_LUT_REVERSE[first]

        offs = 0
        f.write('    { // %d: "%s"\n' % (first, first_s))
        f.write(' ' * 8)
        for second in range(MAX_CONSONANT_INDEX+1, len(PINYIN_LUT)):
            second_s = PINYIN_LUT_REVERSE[second]
            if first_s not in VALID_PAIRS:
                f.write('0')
            elif second_s not in VALID_PAIRS[first_s]:
                f.write('0')
            else:
                f.write('1')

            if first_s == ' ':
                f.write('/*%-6s*/,   ' % (second_s))
            else:
                f.write('/*%-6s*/,   ' % (first_s + second_s))

            if offs % 8 == 7:
                f.write('\n')
                if second < 57-1:
                    f.write(' ' * 8)
            offs = offs + 1

        if offs % 8 != 0:
            f.write('\n')
        f.write('    },\n')

    f.write('};\n')
    f.write('\n')
    f.write('\n')


    f.write('int lime_map_by_pronounce(const char* s, int len)\n{\n')
    f.write('    if (len == -1) {\n')
    f.write('        len = strlen(s);\n')
    f.write('    }\n')
    for k, v in PINYIN_LUT.items():
        f.write('    if (strncmp(s, %-6s, len) == 0) return %d;\n' % ('"' + k + '"', v))
    f.write('    return -1;\n')
    f.write('}\n\n')


    f.write('const char* lime_map_to_pronounce(int id)\n{\n')
    for k, v in PINYIN_LUT_REVERSE.items():
        f.write('    if (id == %2d) return "%s";\n' % (k, v))
    f.write('    return NULL;\n')
    f.write('}\n\n')


    f.write(FUNCTIONS)


    f.close()

if __name__ == '__main__':
    # prepare and build temporary map ----------------------
    for k, v in PINYIN_LUT.items():
        PINYIN_LUT_REVERSE[v] = k

    TOUCH = copy.deepcopy(PINYIN_LUT)
    for consonant, vowels in VALID_PAIRS.items():
        if consonant not in PINYIN_LUT:
            print('Error: unknown %s' % consonant)
        for vowel in vowels:
            if vowel not in PINYIN_LUT:
                print('Error: unknown %s+%s' % (consonant, vowel))
            if vowel in TOUCH:
                del(TOUCH[vowel])

        if consonant in TOUCH:
            del(TOUCH[consonant])

    if len(TOUCH) > 0:
        for k in TOUCH:
            print('Error: missing %s in VALID_PAIRS' % k)

    # write to file ----------------------------------------
    h_fn = 'lime_pinyin.h'
    c_fn = 'lime_pinyin.c'

    write_header(h_fn)
    print('wrote %s' % h_fn)

    write_cfile(h_fn, c_fn)
    print('wrote %s' % c_fn)

